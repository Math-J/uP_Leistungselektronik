#line 1 "start_master.asm"
;;
;; C166/ST10 startup code generated by EDE for project project_gerlach_linhsen_matthaei
;;
;; If modifications are needed, disable generation of the startup code in EDE:
;; In the EDE Project Options dialog select Application, and then Startup. Make
;; sure the checkbox 'Generate system startup code and add it to project' is not
;; checked. Note that changes in EDE will now no longer be reflected in the
;; startup code. Also be aware that the modifications will be overwritten when
;; the checkbox is enabled again.
;;

$EXTEND2
$CASE
$GENONLY
$NOLOCALS
$CHECKCPU16
$CHECKBUS18
$NOMOD166				; disable the internal set of SFRs
$STDNAMES(regxe167f.def)		; define SFRs

			; disable(0)/enable(1) initialization of bit
					; variables at startup
$INCLUDE(head.asm)			; Generic definitions (see product include dir)
#line 1 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"
;@" @(#)head.asm	1.43 02/10/15
;***************************************************************************** 
;*
;* MODULE	: head.asm
;*
;* APPLICATION	: Run time library / Floating point library 80166
;*
;* DESCRIPTION  : This floating point header file is included at the begin
;*                of each floating point source module. And it contains
;*		  several settings and declarations, which are:
;*                - Memory mode selection, to translate the floating 
;*                  point library for segmented or non-segmented memory mode. 
;*		  - Floating point error trap selection, to translate
;*		    floating point library as fast or as accurate. 
;*		  - Declaration of floating point accumulators is done by the
;*		    linker/locator.
;*		  - Floating point register bank definition.
;*		  - Declaration of floating constants.
;*
;* ANNALIST	: Guus Jansman
;*
;* Copyright 1992-2007 Altium BV
;*
;***************************************************************************** 

#line 31 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

; _EXT = 0, extended instruction set disabled
; _EXT = 1, extended instruction set support enabled
#line 36 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; _EXTMAC = 0, MAC instruction support disabled
; _EXTMAC = 1, MAC instruction support enabled
#line 42 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; _EXT2  = 0, C166Sv2.0/Super10 support disabled
; _EXT2 != 1, C166Sv2.0/Super10 support enabled, this implies _EXT

	


; _EXTMAC  = 0, MAC support disabled
; _EXTMAC != 0, MAC support enabled, this implies _EXT

	

	
; _USRSTACK = 0, user stack model disabled
; _USRSTACK = 1, user stack model enabled
#line 60 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; Set default memory model
#line 65 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; _SINGLE_FP = 0, doubles are double precision
; _SINGLE_FP = 1, doubles are single precision (non-ANSI)
#line 71 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; FPCHKSPC = 0, invalid floating point results are undefined (non-ANSI)
; FPCHKSPC = 1, invalid floating point results give proper values

	


; FP_TRAP = 0, floating point error trap handling disabled
; FP_TRAP = 1, floating point error trap handling enabled (only if FPCHKSPC)

	


; FCMPTRAP = 0, floating point comparison will never cause a trap
; FCMPTRAP = 1, floating point comparison can cause trap (only if FP_TRAP)

	


; FPEXC_OP = 0, don't return floating point exception operation type
; FPEXC_OP = 1, return floating point exception operation type (only if FP_TRAP)

	


; _P166 = 0, don't protect multiplication/division (can be overruled by e.g. FIXMUL28)
; _P166 = 1, protect multiplication/division

	


; FIXMUL28 = 0, don't protect multiplication (can be overruled by e.g. _P166)
; FIXMUL28 = 1, protect multiplication

	


; FIXDIV18 = 0, don't protect division (can be overruled by e.g. _P166)
; FIXDIV18 = 1, protect division

	


; FIXCPU21 = 0, don't fix BFLDH/BFLDL problem CPU.21
; FIXCPU21 = 1, fix BFLDH/BFLDL problem CPU.21

	


; FIX_BFWD = 0, no fix for 166 problem S1
; FIX_BFWD = 1, fix 166 problem S1

	


; FIX_CPU1R006 = 0, no fix for 163 problem 01.006
; FIX_CPU1R006 = 1, fix problem 01.006

	


; FIX_STBUS1 = 0, no fix for ST problem ST_BUS1
; FIX_STBUS1 = 1, fix problem ST_BUS1

	


; FIX_EXTSEQ = 0, no fix for problem CR107092
; FIX_EXTSEQ = 1, fix problem CR107092

	


; FIX_LONDON1 = 0, don't fix London1&London1751
; FIX_LONDON1 = 1, fix London1&London1751 (overrules _P166/FIXDIV18)

	


; FPEXCEPT = OLD, old floating point exception method
; FPEXCEPT = IEEE, IEEE floating point exception method

	


; FIX_JMPRACACHE = 0, no fix for Egold problem CR108400:
;		 Program flow after not taken JMPR/JMPA can be broken
; FIX_JMPRACACHE = 1, fix problem CR108400

	


; FIX_EXT1DIV = 0, no fix for Egold problem CR105893:
;		Interrupted division corrupted by division in ISR
; FIX_EXT1DIV = 1, fix problem CR 105893

	


; FIX_EXT1MDL = 0, no fix for Egold proble CR108309:
;		MDL access immediately after a DIV causes wrong PSW values
; FIX_EXT1MDL = 1, fix problem CR 108309

	


; FIX_EXT1MDLMULDIV = 0, no fix for Egold proble CR108904:
;		DIV/MUL interrupted by PEC causes invalid read/write
; FIX_EXT1MDLMULDIV = 1, fix problem CR 108904

	


	
#line 191 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

	$EXTEND			; enable all architecture extensions


	$EXTMAC			; enable MAC architecture extensions


	$EXTEND2		; enable C166Sv2.0/Super10 architecture extensions


	$MODEL( SMALL)
	$NONSEGMENTED
#line 207 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


#line 241 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


#line 248 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"
fbias		EQU	127		; EXCESS-127 float bias
dbias		EQU	1023		; EXCESS-1023 double bias
f_dbias		EQU	fbias - dbias	; bias adjustment for double to single
					; conversion.
d_fbias		EQU	dbias - fbias   ; bias adjustment for single to double 
					; conversion.
fprecb		EQU	24		; # of significant bits (single)
dprecb		EQU	53		; # of significant bits (double)
ffuzz		EQU	24		;
dfuzz		EQU	55		;

facint_2	LIT	'R5'		; Integer accumulator MSW (long).
facint_0	LIT	'R4'		; Integer accumulator LSW.
facint		LIT	'R4'		; Integer accumulator (int).
fptrap		LIT	'R1'		; Floating trap code accumulator.
fpexcop		LIT	'R3'		; Floating exception operation accu
FOS1_MAN0	LIT	'R4'		; Float operand 1 mantissa MSB's
FOS1_MAN0H	LIT	'RH4'		;
FOS1_MAN0L	LIT	'RL4'		;
FOS1_MAN2	LIT	'R5'		; Float operand 1 mantissa LSB's
FOS1_MAN2H	LIT	'RH5'		;
FOS1_MAN2L	LIT	'RL5'		;
FOS1_MAN4	LIT	'R3'		; Float operand 1 mantissa round (RH3)
FOS1_MAN4H	LIT	'RH3'		;
FOS1_MAN4L	LIT	'RL3'		;
FOS1_EXP	LIT	'R1'		; Float operand 1 exponent
FOS1_EXPH	LIT	'RH1'		;
FOS1_EXPL	LIT	'RL1'		;
FOS1_SGN	LIT	'R3'		; Float operand 1 sign (R3.0)
FOS1_SGNH	LIT	'RH3'		;
FOS1_SGNL	LIT	'RL3'		;
FOS2_MAN0	LIT	'R10'		; Float operand 2 mantissa MSB's
FOS2_MAN2	LIT	'R11'		; Float operand 2 mantissa LSB's
FOS2_EXP	LIT	'R2'		; Float operand 2 exponent
FOS2_EXPH	LIT	'RH2'		;
FOS2_EXPL	LIT	'RL2'		;
#line 288 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

FOS2_EXPT	LIT	'R2'		; Float operand 1 temporary exponent
FOS2_EXPTH	LIT	'RH2'		;
FOS2_EXPTL	LIT	'RL2'		;

FOS2_SGN	LIT	'R3'		; Float operand 2 sign (R3.1)
FOS2_SGNH	LIT	'RH3'		;
FOS2_SGNL	LIT	'RL3'		;
FOD1_MAN0	LIT	'R7'		; Double operand 1 mantissa
FOD1_MAN0H	LIT	'RH7'		;
FOD1_MAN0L	LIT	'RL7'		;
FOD1_MAN2	LIT	'R8'		;
FOD1_MAN4	LIT	'R9'		;
FOD1_MAN6	LIT	'R5'		;
FOD1_MAN8	LIT	'R3'		; Double operand 1 mantissa round (RH3)
FOD1_MAN8H	LIT	'RH3'		;
FOD1_MAN8L	LIT	'RL3'		;
FOD1_EXP	LIT	'R1'		; Double operand 1 exponent
FOD1_EXPH	LIT	'RH1'		;
FOD1_EXPL	LIT	'RL1'		;
FOD1_SGN	LIT	'R4'		; Double operand 1 sign (R4.0)
FOD2_MAN0	LIT	'R6'		; Double operand 2 mantissa
FOD2_MAN0H	LIT	'RH6'		;
FOD2_MAN0L	LIT	'RL6'		;
FOD2_MAN2	LIT	'R12'		;
FOD2_MAN4	LIT	'R13'		;
FOD2_MAN6	LIT	'R14'		;
FOD2_EXP	LIT	'R2'		; Double operand 2 exponent
FOD2_EXPH	LIT	'RH2'		;
FOD2_EXPL	LIT	'RL2'		;
#line 320 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

FOD2_EXPT	LIT	'R2'		; Double operand 2 temporary exponent

FOD2_SGN	LIT	'R4'		; Double operand 2 sign (R4.1)

#line 330 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"
; Watchdog timer support
;
; The macro SERVWDT will service the watchdog timer if support has
; been enabled
#line 338 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 340 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"
	


#line 346 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; _BFWDNOP() can be used to solve 166 problem S1
; Erroneous Byte Forwarding for Internal RAM locations (only needed for old uC's).
; Place 0, 1 or 2 _BFWD_NOP's after byte write instructions.
#line 355 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 357 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"



; FIX_MULDIV = IEN, multiplication/division protected by "BCLR IEN"
; FIX_MULDIV = ILVL, multiplication/division protected by "OR PSW, #0F000h"
; FIX_MULDIV does not seem to be used!

	


; _CPU1R006() can be used to solve 163-24D problem CPU 01.006
; (CPU hangs with execution mov Rn, [Rm+#data16]).
; Replace "MOV Rd, [Ri+#data16]" with "_CPU1R006( Rd, Ri, data16 )".
#line 376 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 379 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"



; _STBUS1() can be used to solve ST10 problem ST_BUS1
; (PEC transfers and JMPS).
; Replace "JMPS SEG func, SOF func" with "_STBUS1( func )".
; Of course this macro only influences segmented memory models.
#line 394 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 397 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"



; The macro _LONDON1 expands to an ATOMIC #2 instruction when FIX_LONDON1 is set.
; otherwise _LONDON1 expands to an empty macro. This fix only applies to extended
; architectures.
#line 407 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 409 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"



; the macro FIX_JMPRACACHE can be used to solve Egold problem CR108400
; (Program flow after not taken JMPR/JMPA can be broken).
; After each unconditional JMPR or JMPA, insert an unconditional JMPR
; to the instruction following it.
#line 420 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 422 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

 

; In the floating point code is the instruction "mulu Rx, Ry" replaced by the
; macro MUI( Rx, Ry ).
; Depending of the flags this can bypass many CPU errors, like:
; problem7	Incorrect multiply or divide results during hold states
; problem17	Interrupted multiplication in combination with higher priority
;		interrupt after RETI
; problem28	See CPU.11
; CPU.2		MUL/DIV last instruction in ATOMIC or EXTEND sequence
; CPU.11	Stack underflow trap during restart of interrupted multiply
; CPU.18	Interrupted multiply/divide instructions in internal Flash
#line 477 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; In the floating point code is the instruction "divlu Rx" replaced by the
; macro DIL( Rx, PREMDLHACCESS, POSTMDLACCESS ).
; Depending of the flags this can bypass many CPU errors, like:
; problem7	Incorrect multiply or divide results during hold states
; CPU.2		MUL/DIV last instruction in ATOMIC or EXTEND sequence
; CPU.18	Interrupted multiply/divide instructions in internal Flash
; LONDON1751	DIV result in MDH/MDL can be distorted by explicit CSFR write
; Remember there's a nasty CPU error (CPU.17/problem30) making the overflow
; flag suspicious.
#line 549 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; In the floating point code is the instruction "divX Rx" replaced by the
; macro DIV( INSTRUCTION, Rx, PREMDLHACCESS, POSTMDLACCESS ).
; Depending of the flags this can bypass CPU errors, like:
; CR105893	FIX_EXT1DIV	div corrupted if interrupted by div
; CR108309	FIX_EXT1MDLDIV	mdl access corrupts if after div
; CR108904	FIX_EXT1MDLHMULDIV PEC interrupt corrupts if div after MDL/H access
#line 598 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; Macro _CALL() creates the right code for a direct/indirect function call
; Macro _RET() creates the right code for function return.
; These macro's are added to support _USRSTACK function call and return.
; _USRSTACK code is generated if variable _USRSTACK is set, else a normal
; function call and return (CALL/RET) will be generated.
; Rx is a temporary register. R10 or R11 could be used for Rx without saving
; and restoring the contents in it for the most cases. (R10 now best choice.)
; Register R2 is used in the return stub function and in the return macro
; for tiny and medium model, so operands may not be passed via register R2 !

#line 615 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 620 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 623 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 725 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; Unpack one single precision floating point operand
#line 730 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; 
; Unpack two single precision floating point operands
#line 743 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; Unpack one double precision floating point operand
#line 748 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"


; Unpack two double precision floating point operands
#line 760 "c:\program files (x86)\tasking\c166 v8.7r1\include\head.asm"

#line 24 "start_master.asm"
$INCLUDE(_c_init.asm)			; Initialize C variables
#line 1 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
;*****************************************************************************
;*
;* MODULE	: _c_init.asm
;*
;* DESCRIPTION	: C copy table code for C16x/ST10 microcontroller.
;*
;*		- Initialization of static variables in internal or external
;*		  ram. C variables which have to be initialized are specified
;*		  in ROM section C166_INIT. C variables which must
;*		  be cleared are specified in ROM section C166_BSS.
;*		- Set user stack pointer.
;*
;* Copyright 1997-2007 Altium BV
;*
;*****************************************************************************

#line 19 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"


PUBLIC __C_INIT
						
	; Predefined functions for register R1, R2 and R3.
	POF_RAM		LIT	'R1'	; Page offset address ram data.
	SOF_RAM		LIT	'R1'	; Segment offset address ram data.
	SOF_RAM_H	LIT	'RH1'	; Segment address high byte.
	POF_ROM		LIT	'R2'	; Page offset address rom data.
	SOF_ROM		LIT	'R2'	; Segment offset address rom data.
	SOF_ROM_H	LIT	'RH2'	; Segment address high byte.
	BP_RAM		LIT	'R3'	; Bit position ram data

;*****************************************************************************
;* __C_INIT
;*****************************************************************************
__C_INIT_PR	SECTION CODE PUBLIC 'C_INIT'

#line 39 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"

__C_INIT	PROC FAR
		
#line 44 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"

	BOTTOM_BITRAM	LIT  '0FD00H'


#line 50 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"



					; Clear bit addressable memory
	MOV	R1, #0FDFEH		; R1 = top of bit addressable area
loop:	CMP	R1, #CSTART_RBANK + 2	; if( R1 in bit addressable area )
	JMP	CC_EQ, cbclr		; then continue next (bit) word clear.
	
	CMP	R1, #CSTART_RBANK	; if (R0 in bit addressable area )
	JMP     CC_EQ, cbclr		; then continue next (bit) word clear.
	
	MOV	[R1], ZEROS		; clear
cbclr:	CMPD2	R1, # BOTTOM_BITRAM	; if( not bottom bit addressable area )
	JMP	CC_NE, loop		; then continue next (bit) word clear
	


					 ; C166_INIT

	MOV	R4,  #POF ?C166_INIT_HEAD ; move intra-page offset address rom
					 ; data section C166_INIT to R4
INIT_DPP0:				 ;
	MOV	DPP0,#PAG ?C166_INIT_HEAD ; load data page pointer register DPP0
					 ; with data page of rom data C166_INIT
	NOP				 ; delay for pipeline effect
#line 78 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"

		
INIT:					;
	MOV	R5, [R4+]		; INIT block header code -> R5
	CMP	R5, #01H		; check if header code 1 (bit)
	JMP	CC_EQ, INIT_01		;
	


	CMP	R5, #05H		; check if header code is 5 (near)
  
	JMP	CC_EQ, INIT_05		;
	
#line 94 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  



	CMP	R5, #06H		; check if header code 6 (far)
	JMP	CC_EQ, INIT_06		;
	
	CMP	R5, #07H		; check if header code 7 (huge)
	JMP	CC_NE, INIT_END		; if(no header code) end initialization
	

INIT_07:				; initialize huge ram data. (data > 64K)
	MOV	SOF_RAM, [R4+]		; move intra-segment offset address ram
					; data block to SOF_RAM=R1
	MOV	R3, [R4+]		; move segment address ram data block 
					; to register R3
					; process data page number ram data
	MOV	RH3, SOF_RAM_H		; R3.15, R3.14: low bits of page number (byte forwarding)
	
	
	
	ROL	R3, #2			; shift R3.15, R3.14 to R3.1 and R3.0
	AND	R3, #03FFH		; mask page number
	MOV	DPP1, R3		; load data page pointer register DPP1
					; with data page of ram data block
	BCLR	SOF_RAM.15		; DPP1:POF_RAM ->SOF_RAM
	BSET	SOF_RAM.14		;
					;
	MOV	SOF_ROM, [R4+]		; move intra-segment offset address rom
					; data block to SOF_ROM=R2
	MOV	R3, [R4+]		; move segment address rom data block
					; to R3
					; process data page number rom data
	MOV	RH3, SOF_ROM_H		; R3.15, R3.14=low bits of page number (byte forwarding)
	
	

	ROL	R3, #2			; shift R3.15, R3.14 to R3.1 and R3.0
	AND	R3, #03FFH		; mask page number
	MOV	DPP2, R3		; load data page pointer register DPP2
					; with data page of rom data block
	BSET	SOF_ROM.15		; DPP2:POF_ROM ->SOF_ROM
	BCLR	SOF_ROM.14		;
					;
	MOV	R5, [R4+]		; number of bytes (R6:R5) to move from
	MOV	R6, [R4+]		; rom to ram. MSW=R6, LSW=R5 (long word)
					;
MB07_3:	; Service Watchdog Timer (if enabled)
	CMPD1	R5, #0			; test if all bytes are moved and
	JMP	CC_NE, MB07_1 		; decrement number of bytes to move.
	
	CMPD1	R6, #0			;
  
	JMP	CC_EQ, MB07_4		;
	
#line 152 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  
MB07_1:	MOVB	[SOF_RAM], [SOF_ROM]	; move byte from rom to ram
	CMPI1	SOF_RAM, #07FFFH	; test end of data page and inc SOF_RAM
	JMP	CC_NE, MB07_2		; if(no page end) cont init current page
	
	MOV	SOF_RAM, #04000H	; preset offset address ram data
	ADD	DPP1, #1		; next page of ram data; increment DPP1
MB07_2:	CMPI1	SOF_ROM, #0BFFFH	; test end of page and inc SOF_ROM
	JMP	CC_NE, MB07_3		; if(no page end) cont init current page
	
	MOV	SOF_ROM, #08000H	; preset offset address rom data
	ADD	DPP2, #1		; next page of rom data; increment DPP2
	JMP	CC_UC, MB07_3		; jump for next byte move
  
MB07_4:	MOV 	DPP1, #PAG ?BASE_DPP1	; restore data page register DPP1 and
	MOV 	DPP2, #PAG ?BASE_DPP2	; DPP2 to their default values.
	JMP	CC_UC, INIT		; next initialization
  

INIT_06:				; initialize far ram data. (CPU mode 
					; is segmented with DPP usage linear
					; or paged.)
	MOV	POF_RAM, [R4+]		; move intra-page offset address ram
					; data block to POF_RAM=R1
	BCLR	SOF_RAM.15		; DPP1:POF_RAM ->SOF_RAM
	BSET	SOF_RAM.14		;
	MOV	DPP1, [R4]		; load data page pointer register DPP1
					; with data page of ram data block
	ADD	R4, #2			; inc offset address to ram data section
					; C166_INIT and also insure a delay for
					; pipeline effect.(DPP1 set)
					;
	MOV	POF_ROM, [R4+]		; move intra-page offset address rom
					; data block to POF_ROM=R2
	BSET	SOF_ROM.15		; DPP2:POF_ROM ->SOF_ROM
	BCLR	SOF_ROM.14		;
	MOV	DPP2, [R4]		; load data page pointer register DPP2
					; with data page of rom data block
	ADD	R4, #2			; inc offset address to rom data section
					; C166_INIT and also insure a delay for
					; pipeline effect.(DPP2 set)
					;
	MOV	R5, [R4+]		; number of bytes to move from rom to
					; ram for specified data block.
					;
MB06_1:	; Service Watchdog Timer (if enabled)
	CMPD1	R5, #0			; test on data block end
  
	JMP	CC_EQ, MB06_2		;
	
	MOVB	[SOF_RAM], [SOF_ROM+]	; move byte from rom to ram, inc SOF_ROM
	CMPI1	SOF_RAM, #07FFFH	; test end of data page and inc SOF_RAM
	JMP	CC_NE, MB06_1		; if(no page end) cont init current page
	
	MOV	SOF_RAM, #04000H	; preset offset address ram data
	ADD	DPP1, #1		; next page of ram data; increment DPP1
	JMP	cc_UC, MB06_1		; jump for next byte move
MB06_2:	MOV 	DPP1, #PAG ?BASE_DPP1	; restore data page register DPP1 and
	MOV 	DPP2, #PAG ?BASE_DPP2	; DPP2 to their default values.
	JMP	CC_UC, INIT		; next initialization
#line 218 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  



INIT_05:				; initialize near ram data. (DPP usage
					; is linear, CPU mode is segmented
					; for SMALL memory model and not
					; segmented for TINY memory model.)
	MOV	SOF_RAM, [R4+]		; move intra-segment offset address ram
					; data block to SOF_RAM=R1
					;
	MOV	SOF_ROM, [R4+]		; move intra-segment offset address rom
					; data block to SOF_ROM=R2
					;
	MOV	R5, [R4+]		; number of bytes to move from rom to
					; ram for specified data block.
  
	MOV	DPP0, #PAG ?BASE_DPP0	; restore DPP0 to its default value
  
MB05_1:	; Service Watchdog Timer (if enabled)
	CMPD1	R5, #0			; test on data block end, and delay
					; for pipeline effect if DPP0 is
					; restored for SMALL memory model.
#line 244 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  
	JMP	CC_EQ, INIT_DPP0	; if( block end ) reload data page
	; pointer register DPP0 with data page
					; of rom data C166_INIT and start next
					; initialization.
  
	MOVB	[SOF_RAM], [SOF_ROM+]	; byte move rom to ram, inc SOF_ROM
	ADD	SOF_RAM, #1		; inc SOF_RAM
	JMP	CC_UC, MB05_1		; jump for next byte move


#line 364 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
; NO BIT INITIALIZATION
					;
INIT_01:
	ADD	R4,#0CH			; skip DBPTR, DPTR and DW
	JMP	CC_UC, INIT		; continue with next initialization


INIT_END:				;

					; C166_BSS

	MOV	R4, #POF ?C166_BSS_HEAD	; move intra-page offset address rom
					; data section C166_BSS to R4
BSS_DPP0:				;
	MOV	DPP0,#PAG ?C166_BSS_HEAD ; load data page pointer register DPP0
					; with data page of rom data C166_BSS
	NOP				; delay for pipeline effect
#line 384 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"

BSS:					;
	MOV	R5, [R4+]		; BSS block header code -> R5

	CMP	R5, #05H		; check if header code 5 (near)
  
	JMP	CC_EQ, BSS_05		;
	
#line 395 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  


	CMP	R5, #06H		; check if header code 6 (far)
	JMP	CC_EQ, BSS_06		;
	
	CMP	R5, #07H		; check if header code 7 (huge)
	JMP	CC_NE, BSS_END		; if(no header code) end initialization
	

BSS_07:					; clear huge ram data (data > 64 K)
	MOV	SOF_RAM, [R4+]		; move intra-segment offset address ram
					; data block to SOF_RAM=R1
	MOV	R3, [R4+]		; move segment address ram data block
					; to R3
					; process data page number ram data 
	MOV	RH3, SOF_RAM_H		; R3.15, R3.14=low bits of page number *byte forwarding)
	
	

	ROL	R3, #2			; shift R3.15, R3.14 to R3.1 and R3.0
	AND	R3, #03FFH		; mask page number
	MOV	DPP1, R3		; load data page pointer register DPP1
					; with data page of ram data block
	BCLR	SOF_RAM.15		; DPP1:POF_RAM ->SOF_RAM
	BSET	SOF_RAM.14		;
					;
	MOV	R5, [R4+]		; number of bytes (R6:R5) to clear in
	MOV	R6, [R4+]		; specified ram data block. 
					; MSW=R6, LSW=R5 (long word)
					;
CB07_2:	; Service Watchdog Timer (if enabled)
	CMPD1	R5, #0			; test if all bytes are cleared and
	JMP	CC_NE, CB07_1 		; decrement number of bytes to clear.
	; 
	CMPD1	R6, #0			;
  
	JMP	CC_EQ, CB07_3		;
	; 
#line 437 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  
CB07_1:	MOVB	[SOF_RAM], ZEROS	; clear byte
	CMPI1	SOF_RAM, #07FFFH	; test end of data page and inc SOF_RAM
	JMP	CC_NE, CB07_2		; if(no page end) next byte clear
	; 
	MOV	SOF_RAM, #04000H	; preset offset address ram data
	ADD	DPP1, #1		; next page ram data; increment DPP1
	JMP	CC_UC, CB07_2		; jump for next byte clear
  
CB07_3:	MOV 	DPP1, #PAG ?BASE_DPP1	; restore data page register DPP1.
	JMP	CC_UC, BSS		; next initialization
  

BSS_06:					; clear far ram data. (CPU mode is
					; segmented with DPP usage linear or
					; paged.)
	MOV	POF_RAM, [R4+]		; move intra-page offset address ram
					; data block to POF_RAM=R1
	BCLR	SOF_RAM.15		; DPP1:POF_RAM ->SOF_RAM
	BSET	SOF_RAM.14		;
	MOV	DPP1, [R4]		; load data page pointer register DPP1
					; with data page of ram data block
	ADD	R4, #2			; inc offset address to ram data section
					; C166_BSS and also insure a delay for 
					; pipeline effect. (DPP1 set)
					;
	MOV	R5, [R4+]		; number of bytes to clear in specified
					; ram data block
					;
CB06_1:	; Service Watchdog Timer (if enabled)
	CMPD1	R5, #0			; test on data block end
  
	JMP	CC_EQ, CB06_2 		;
	; 
#line 474 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  
	MOVB	[SOF_RAM], ZEROS	; clear byte
	ADD	SOF_RAM, #1		; inc SOF_RAM
	JMP	CC_UC, CB06_1		; jump for next byte clear
  
CB06_2:	MOV 	DPP1, #PAG ?BASE_DPP1	; restore data page register DPP1
	JMP	CC_UC, BSS		; next initialization
  



BSS_05:					; clear near ram data. (DPP usage
					; is linear, CPU mode is segmented
					; for SMALL memory model and not
					; segmented for TINY memory model.)
	MOV	SOF_RAM, [R4+]		; move intra-segment offset address ram
					; data block to SOF_RAM=R1
					;
	MOV	R5, [R4+]		; number of bytes to clear in specified
					; ram data block
  
	MOV	DPP0, #PAG ?BASE_DPP0	; restore DPP0 to its default value
  
CB05_1:	; Service Watchdog Timer (if enabled)
	CMPD1	R5, #0			; test on data block end, and delay for
					; pipeline effect if DPP0 is restored
					; for SMALL memory model
#line 504 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  
	JMP	CC_EQ, BSS_DPP0		; if( block end ) reload data page
	; pointer register DPP0 with data page
					; of rom data C166_BSS and start next
					; initialization
  
	MOVB	[SOF_RAM], ZEROS	; clear byte
	ADD	SOF_RAM, #1		; inc SOF_RAM
	JMP	CC_UC, CB05_1		; jump for next byte clear
	

BSS_END:

  
	MOV	DPP0, #PAG ?BASE_DPP0	; restore DPP0 to its default value
#line 521 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  
  

#line 532 "c:\program files (x86)\tasking\c166 v8.7r1\include\_c_init.asm"
  	
		ret				; return address on the system stack	
__C_INIT	ENDP
__C_INIT_PR	ENDS				
#line 25 "start_master.asm"

	NAME	CSTART			; module name

	PUBLIC	__IDLE			; cstart end
	PUBLIC	__EXIT			; address to jump to on 'exit()'
	EXTERN	_main:FAR		; start label user program
	EXTERN __C_INIT:FAR

__CSTART_PR	SECTION CODE WORD PUBLIC 'CPROGRAM'
__CSTART 	PROC TASK __CSTART_TASK INTNO __CSTART_INUM = 0

	DISWDT						;  Disable watchdog timer

	MOV	R0,#0x4009
	MOV	ADDRSEL1, R0
	MOV	R0,#0x0000
	MOV	ADDRSEL2, R0
	MOV	R0,EBCMOD0
	AND	R0, #(~0xFFFF)|0
	OR	R0, #((0x7145&~0)&0xFFFF)
	MOV	EBCMOD0, R0
	MOV	R0,#0x0010
	MOV	EBCMOD1, R0
	MOV	R0,#0x0040
	MOV	TCONCS0, R0
	MOV	R0,FCONCS0
	AND	R0, #(~0x0037)|0
	OR	R0, #((0x0021&~0)&0x0037)
	MOV	FCONCS0, R0
	MOV	R0,#0x0040
	MOV	TCONCS1, R0
	MOV	R0,#0x0021
	MOV	FCONCS1, R0
	MOV	R0,#0x7c3d
	MOV	TCONCS2, R0
	MOV	R0,#0x0021
	MOV	FCONCS2, R0
	EXTR	#1
	MOV	CMCTR, #0x8000

	MOV	VECSEG, #(0xC00000>>16)			; Set vector table segment

	ATOMIC	#3
	MOV	SP,	#SOF ?SYSSTACK_TOP		; Set stack pointer.
	MOV	STKOV,	#SOF ?SYSSTACK_BOTTOM + 6*2	; Set stack overflow pointer.
	MOV	STKUN,	#SOF ?SYSSTACK_TOP		; Set stack underflow pointer.

	MOV	CP,	#CSTART_RBANK	; Set context pointer.
	NOP

	MOV	DPP0, #PAG ?BASE_DPP0	; Set data page pointer.
	MOV	DPP1, #PAG ?BASE_DPP1	; Initialise these before we can make a
	MOV	DPP2, #PAG ?BASE_DPP2	; user stack call below
	; Set user stack pointer
	; To avoid problems when the userstack is located at the end of a page, the
	; initial value is set using base + size.
	MOV	R0, #?USRSTACK_BOTTOM + (?USRSTACK_TOP - ?USRSTACK_BOTTOM)

	BFLDH	PSW, #3, #2		; set local register bank 0 (10)

	MOV	R0, #?USRSTACK0_BOTTOM + (?USRSTACK0_TOP - ?USRSTACK0_BOTTOM)

	BFLDH	PSW, #3, #3		; set local register bank 1 (11)

	MOV	R0, #?USRSTACK1_BOTTOM + (?USRSTACK1_TOP - ?USRSTACK1_BOTTOM)


	BFLDH	PSW, #3, #0		; set to global user stack

	EINIT				; End of initialization

	call	__C_INIT		; return address pushed on system stack (@Rx not used)			; initialization of global/static data

	BSET	IEN			; allow monitor to break application

        MOV     R12, #0			; set argc to 0
        MOV     R13, #0			; set argv[] to 0
        MOV     R14, #0			;

	call	_main		; return address pushed on system stack (@Rx not used)

; The exit() function causes normal program termination to occur. First, all 
; functions registered by the atexit() function are called in the reverse 
; order. Next, all open streams with unwritten buffered data are flushed, all 
; open streams are closed and all files created by the tmpfile() function are 
; removed. The status value passed to exit is returned in R4.
__EXIT: LABEL FAR			; the exit() or abort() function jumps
					; to this entry.
__IDLE: IDLE				; Power down CPU until peripheral inter-
					; rupt or external interrupt occurs.
	JMPR	CC_UC, __IDLE		; set idle mode again.
	RETV				; Virtual return.
__CSTART	ENDP
__CSTART_PR	ENDS

C166_US	SECTION	LDAT WORD GLBUSRSTACK 'CUSTACK'
	DS	2			; Allocate a user stack of at least 2 bytes
C166_US	ENDS

; Define empty user stack used with localregister bank 0.
C166_US0 SECTION LDAT WORD GLBUSRSTACK 'CUSTACK'
C166_US0 ENDS
C166_US1 SECTION LDAT WORD GLBUSRSTACK 'CUSTACK'
C166_US1 ENDS
C166_US2 SECTION LDAT WORD GLBUSRSTACK 'CUSTACK'
C166_US2 ENDS

C166_SYSSTACK SECTION HDAT WORD SYSSTACK
	DS 256 * 2	; Reserve stack size in words
C166_SYSSTACK ENDS
	SSKDEF 7			; System stack size

CSTART_RBANK REGDEF R0-R15		; Register usage


	END
